module Stdlib

  use export int.Int
  use export int.ComputerDivision
  use export int.MinMax
  use export int.Abs
  use export mach.int.Int
  use export list.List
  use export list.Append
  use export ocaml.Exceptions
  use export option.Option
  use export ref.Ref
  use export ref.Refint

  let invalid_arg (s: string)
    raises  { Invalid_argument }
    returns { _ -> false }
  = raise (Invalid_argument s)

  val ignore (_: 'a) : unit

  let function fst (x: ('a, 'b)) : 'a =
    let r, _ = x in r

  let function snd (x: ('a, 'b)) : 'b =
    let _, r = x in r

  type result 'a 'b = Ok 'a | Error 'b

  function (%) (x y: int) : int = mod x y

  predicate same_location 'a 'a

  axiom same_location_eq: forall x y: 'a.
    same_location x y -> x = y

  val function (==) (x y: 'a) : bool
    ensures { result <-> same_location x y }

  val function (!=) (x y: 'a) : bool
    ensures { result <-> not same_location x y }

  val function (~=) (x y: int) : bool
    ensures { result <-> not x = y }

  val (|>) (x: 'a) (f: 'a -> 'b) : 'b
    ensures { result = f x }

  let (~-_) (x: int) = -x

  let succ (x: int) = x + 1

  predicate is_pre_order (cmp: 'a -> 'a -> int) =
    (forall x. cmp x x = 0) /\
    (forall x y. cmp x y = 0 <-> cmp y x = 0) /\
    (forall x y. cmp x y < 0 <-> cmp y x > 0) /\
    (forall x y z.
      (cmp x y = 0 -> cmp y z = 0 -> cmp x z = 0) /\
      (cmp x y = 0 -> cmp y z < 0 -> cmp x z < 0) /\
      (cmp x y < 0 -> cmp y z = 0 -> cmp x z < 0) /\
      (cmp x y < 0 -> cmp y z < 0 -> cmp x z < 0))

  lemma cmp_eq: forall x y: 'a, cmp: 'a -> 'a -> int.
    is_pre_order cmp -> (cmp x y = 0 <-> x = y)

  val function compare (x y: 'a) : int
  axiom compare_pre_order : is_pre_order (fun (x: 'a) (y: 'a) -> compare x y)

  use import seq.Seq as Seq

  scope import Array

    type my_array 'a = private {
      mutable ghost elts : seq 'a;
                  length : int;
    } invariant { 0 <= length = Seq.length elts }

    function ([]) (a: my_array 'a) (i: int) : 'a = Seq.([]) a.elts i

    function get (a: my_array 'a) (i: int) : 'a = a[i]

    val get (a: my_array 'a) (i: int) : 'a
      requires { [@expl:index in array bounds] 0 <= i < length a }
      ensures  { result = a[i] }

    val set (a: my_array 'a) (i: int) (v: 'a) : unit
      writes   { a }
      requires { 0 <= i < length a }
      ensures  { a.elts = (old a.elts)[i <- v] }

    meta coercion function elts

    val ([]) (a: my_array 'a) (i: int) : 'a
      requires { [@expl:index in array bounds] 0 <= i < a.length }
      ensures  { result = a[i] }

    val ([]<-) (a: my_array 'a) (i: int) (v: 'a) : unit writes {a}
      requires { [@expl:index in array bounds] 0 <= i < a.length }
      ensures  { a.elts = (old a.elts)[i <- v] }

    val make (n: int) (v: 'a) : my_array 'a
      requires { [@expl:array creation size] n >= 0 }
      ensures  { forall i. 0 <= i < n -> result[i] = v }
      ensures  { result.length = n }

    let init (n: int) (f: int -> 'a) : my_array 'a
      requires { [@expl:array creation size] n >= 0 }
      ensures  { forall i. 0 <= i < n -> result[i] = f i }
      ensures  { length result = n }
    = let a = make n (f 0) in
      for i = 1 to n - 1 do
        invariant { forall j. 0 <= j < i -> a[j] = f j }
        a[i] <- f i
      done;
      a

    val empty () : my_array 'a
      ensures { result.length = 0 }

    let blit (a1: my_array 'a) (ofs1: int)
             (a2: my_array 'a) (ofs2: int) (len: int) : unit writes {a2}
      requires { 0 <= ofs1 /\ 0 <= len /\ ofs1 + len <= length a1 }
      requires { 0 <= ofs2 /\             ofs2 + len <= length a2 }
      ensures  { forall i:int.
        (0 <= i < ofs2 \/ ofs2 + len <= i < length a2) -> a2[i] = old a2[i] }
      ensures  { forall i:int.
        ofs2 <= i < ofs2 + len -> a2[i] = a1[ofs1 + i - ofs2] }
    =
      for i = 0 to len - 1 do
        invariant { forall k. not (0 <= k < i) -> a2[ofs2 + k] = old a2[ofs2 + k] }
        invariant { forall k. 0 <= k < i -> a2[ofs2 + k] = a1[ofs1 + k] }
        a2[ofs2 + i] <- a1[ofs1 + i];
      done

    val sort (cmp: 'a -> 'a -> int) (a: my_array 'a) : unit
      requires { is_pre_order cmp }
      ensures  { forall i j. 0 <= i <= j < length a -> cmp a[i] a[j] <= 0 }

    let rec function to_list_range (a: my_array 'a) (l u: int) : list 'a
      requires { l >= 0 /\ u <= a.length }
      variant  { u - l }
    = if u <= l then Nil else Cons a[l] (to_list_range a (l+1) u)

    use list.Append

    let rec lemma to_list_append (a: my_array 'a) (l m u: int)
      requires { 0 <= l <= m <= u <= a.length }
      variant  { m - l }
      ensures  { to_list_range a l m ++ to_list_range a m u =
                 to_list_range a l u }
    = if l < m then to_list_append a (l+1) m u

    let to_list (a: my_array 'a) : list 'a
      ensures { result = to_list_range a 0 (length a) }
    = to_list_range a 0 (length a)

    use seq.Mem

    predicate mem (x: 'a) (a: my_array 'a) =
      Mem.mem x a

  end

  type array 'a = my_array 'a

  scope Sys

    val constant max_array_length : int
    axiom non_neg_max_array_length : 0 < max_array_length

  end

  scope List

    use export list.List
    use export list.Length
    use export list.Mem
    use export list.NumOcc
    use import list.Append    as A
    use import list.Reverse   as R
    use import list.RevAppend as RA

    let function rev (l: list 'a) : list 'a =
      R.reverse l

    let function append (l1 l2: list 'a) : list 'a =
      A.(++) l1 l2

    let function rev_append (s t: list 'a) : list 'a =
      RA.rev_append s t

    val mem (x: 'a) (l: list 'a) : bool
      ensures { result <-> mem x l }

    val filter (p: 'a -> bool) (l: list 'a) : list 'a
      ensures { forall x. mem x result <-> p x && mem x l }
      ensures { forall x. mem x result -> num_occ x result = num_occ x l }

    let find_all (p: 'a -> bool) (l: list 'a)
      ensures { forall x. mem x result -> p x && mem x l }
      ensures { forall x. mem x result -> num_occ x result = num_occ x l }
    = filter p l

    val list_exists (p: 'a -> bool) (l: list 'a) : bool
      ensures { result <-> exists x. mem x l /\ p x }

    let rec function assoc_opt (x: 'a) (l: list ('a, 'b)) : option 'b
      variant { l }
    = match l with
      | Nil -> None
      | Cons (a, b) t -> if a == x then Some b else assoc_opt x t
      end

  end

  scope String

    use export string.String
    use import string.Char as C

    val eq (s1 s2: string) : bool
      ensures { result <-> C.eq_string s1 s2 }

    val lt (s1 s2: string) : bool
      ensures { result <-> lt s1 s2 }

    val le (s1 s2: string) : bool
      ensures { result <-> le s1 s2 }

  end

  type nat = Nat int

  type tz = Tz int

  scope Tz

    type t = tz
    
    let function eq (t1:tz) (t2:tz) : bool =
      match t1, t2 with
      | Tz n1, Tz n2 -> n1 = n2
      | _, _ -> false
      end
  
  end

  exception Fail
  let failwith ()
    raises { Fail }
    returns { _ -> false }
  = raise Fail

  scope Option

    use export option.Option

    let get (o: option 'a) : 'a
      ensures { not is_none o -> match o with None -> false | Some a -> result = a end }
      raises { Invalid_argument _ -> is_none o }
    = match o with None -> invalid_arg "Option.get" | Some a -> a end

  end

  type set 'a = Set (list 'a)

  scope Set

    type t 'a = set 'a

    let function mem (x : 'a) (sxs : set 'a) =
      match sxs with
      | Set xs -> List.mem x xs
      end

    let function update (x : 'a) (b : bool) (sxs : set 'a) =
      match sxs with
      | Set xs -> Set (
        if b then
          let rec add (st : list 'a) (ys : list 'a)
            variant { ys }
          = match ys with
            | Nil -> List.rev (Cons x st)
            | Cons y ys ->
              if compare x y < 0 then List.rev (List.rev_append (Cons y ys) (Cons x st))
              else if x == y then xs
              else add (Cons y st) ys
            end
          in add Nil xs
        else
          let rec remove (st : list 'a) (ys : list 'a)
            variant { ys }
          = match ys with
            | Nil -> xs
            | Cons y ys ->
              if compare x y < 0 then xs
              else if x == y then List.rev (List.rev_append ys st)
              else remove (Cons y st) ys
            end
          in remove Nil xs
      )
      end

  end

  type map 'k 'v = Map (list ('k, 'v))

  scope Map

    type t 'k 'v = map 'k 'v

    let function get (k : 'k) (mxs : map 'k 'v) =
      match mxs with Map xs -> List.assoc_opt k xs | _ -> None end

    let function update (k : 'k) (vo : option 'v) (mkvs : map 'k 'v) : map 'k 'v =
      match mkvs with
      | Map kvs -> Map (
        match vo with
        | None ->
          let rec remove st rkvs
            variant { rkvs }
          = match rkvs with
            | Nil -> kvs
            | Cons kv rkvs ->
              match kv with
              | (k', _) ->
                if compare k k' < 0 then kvs
                else if k == k' then List.rev (List.rev_append rkvs st)
                else remove (Cons kv st) rkvs
              end
            end
          in remove Nil kvs
        | Some v ->
          let rec add st rkvs
            variant { rkvs }
          = match rkvs with
            | Nil -> List.rev (Cons (k, v) st)
            | Cons kv rkvs ->
              match kv with
              | (k', _) ->
                if compare k k' < 0 then List.rev_append (Cons kv rkvs) (Cons (k,v) st)
                else if k == k' then List.rev_append rkvs (Cons (k,v) st)
                else add (Cons kv st) rkvs
              end
            end
          in add Nil kvs
        end
      )
      end

  end

  type address = Address string

  scope Address

    type t = address

    let function eq (a1:address) (a2:address) : bool =
      match a1, a2 with
      | Address s1, Address s2 -> String.eq s1 s2
      | _, _ -> false
      end
  
  end

  type key_hash = Key_hash string

  scope Key_hash

    type t = Key_hash

  end


  type rep = RepInt | RepUnit | RepPair (rep, rep)

  let function any_rep () : rep =
    any rep

  type param = ParamInt int | ParamUnit | ParamPair (param, param)

  (*let rec typecheck (r:rep) (p:param) : bool
    variant { r }
  = match (r, p) with
  | RepInt, ParamInt _ | RepUnit, ParamUnit -> true
  | RepPair (r1, r2) , ParamPair (p1, p2) -> typecheck r1 p1 && typecheck r2 p2
  | RepInt, ParamUnit | RepInt, ParamPair _ | RepUnit, ParamInt _ | RepUnit, ParamPair _ | RepPair _, ParamInt _ | RepPair _, ParamUnit -> false
  end*)

  type contract = Contract (address, rep)

  type operation = Transfer_tokens param tz contract
  type operations = list operation

  let rec type_of (p:param) : rep
    variant { p }
  = match p with
    | ParamInt _ -> RepInt
    | ParamUnit -> RepUnit
    | ParamPair (p1, p2) -> RepPair (type_of p1, type_of p2)
    end

  scope Contract

    type t = contract

    let function contract (addr:address) (p : param) : option contract =
      let r = type_of p in
      if any bool then Some (Contract (addr, r)) else None
      (*let r = any_rep () in
      if typecheck r p then Some (Contract (addr, r)) else None*)

  end

  scope Operation

    type t = operation

    let function transfer_tokens (p:param) (t:tz) (c:contract) : operation =
      Transfer_tokens p t c

  end

  type timestamp = Timestamp string

  scope Timestamp

    type t = timestamp

    let function lt (t1:timestamp) (t2:timestamp) : bool =
      match t1, t2 with
      | Timestamp s1, Timestamp s2 -> String.lt s1 s2
      | _, _ -> false
      end

    let function le (t1:timestamp) (t2:timestamp) : bool =
      match t1, t2 with
      | Timestamp s1, Timestamp s2 -> String.le s1 s2
      | _, _ -> false
      end

  end

  scope Env

    type t = { env_now : timestamp; env_amount : tz; env_source : address; env_sender : address }

    let env = None : option t

    let get (env : option t) : t
      requires { match env with None -> false | Some _ -> true end }
      raises   { Invalid_argument _ -> false }
    = Option.get env

    let now (env: t) : timestamp =
      env_now env

    let amount (env: t) : tz =
      env_amount env

    let source (env: t) : address =
      env_source env

    let sender (env: t) : address =
      env_sender env

  end

  scope Global

    let function get_now (env : option Env.t) : timestamp
      requires { match env with None -> false | Some _ -> true end }
      raises   { Invalid_argument _ -> false }
    = Env.env_now (Env.get env)

    let function get_amount (env : option Env.t) : tz
      requires { match env with None -> false | Some _ -> true end }
      raises   { Invalid_argument _ -> false }
    = Env.env_amount (Env.get env)

    let function get_source (env : option Env.t) : address
      requires { match env with None -> false | Some _ -> true end }
      raises   { Invalid_argument _ -> false }
    = Env.env_source (Env.get env)

    let function get_sender (env : option Env.t) : address
      requires { match env with None -> false | Some _ -> true end }
      raises   { Invalid_argument _ -> false }
    = Env.env_sender (Env.get env)

  end

  type key = string

  scope Key

    type t = key

  end

  type signature = Signature string

  scope Signature

    type t = signature
    
  end

end
(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.Abs.
Require int.MinMax.
Require int.ComputerDivision.
Require list.List.
Require list.Length.
Require list.Mem.
Require option.Option.
Require list.Append.
Require list.Reverse.
Require list.RevAppend.
Require list.NumOcc.

(* Why3 assumption *)
Inductive ref (a:Type) :=
  | ref'mk : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Arguments ref'mk {a}.

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:ref a) : a :=
  match v with
  | ref'mk x => x
  end.

(* Why3 assumption *)
Definition fst {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (x:(a* b)%type) : a :=
  match x with
  | (r, _) => r
  end.

(* Why3 assumption *)
Definition snd {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}
    (x:(a* b)%type) : b :=
  match x with
  | (_, r) => r
  end.

(* Why3 assumption *)
Inductive result (a:Type)
  (b:Type) :=
  | Ok : a -> result a b
  | Error : b -> result a b.
Axiom result_WhyType : forall (a:Type) {a_WT:WhyType a}
  (b:Type) {b_WT:WhyType b}, WhyType (result a b).
Existing Instance result_WhyType.
Arguments Ok {a} {b}.
Arguments Error {a} {b}.

Parameter same_location: forall {a:Type} {a_WT:WhyType a}, a -> a -> Prop.

Axiom same_location_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a), same_location x y -> (x = y).

Parameter infix_eqeq:
  forall {a:Type} {a_WT:WhyType a}, a -> a -> Init.Datatypes.bool.

Axiom infix_eqeq'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a),
  ((infix_eqeq x y) = Init.Datatypes.true) <-> same_location x y.

Parameter infix_exeq:
  forall {a:Type} {a_WT:WhyType a}, a -> a -> Init.Datatypes.bool.

Axiom infix_exeq'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a),
  ((infix_exeq x y) = Init.Datatypes.true) <-> ~ same_location x y.

Parameter infix_tleq:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Axiom infix_tleq'spec :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  ((infix_tleq x y) = Init.Datatypes.true) <-> ~ (x = y).

(* Why3 assumption *)
Definition is_pre_order {a:Type} {a_WT:WhyType a}
    (cmp:a -> a -> Numbers.BinNums.Z) : Prop :=
  (forall (x:a), ((cmp x x) = 0%Z)) /\
  (forall (x:a) (y:a), ((cmp x y) = 0%Z) <-> ((cmp y x) = 0%Z)) /\
  (forall (x:a) (y:a), ((cmp x y) < 0%Z)%Z <-> (0%Z < (cmp y x))%Z) /\
  (forall (x:a) (y:a) (z:a),
   (((cmp x y) = 0%Z) -> ((cmp y z) = 0%Z) -> ((cmp x z) = 0%Z)) /\
   (((cmp x y) = 0%Z) -> ((cmp y z) < 0%Z)%Z -> ((cmp x z) < 0%Z)%Z) /\
   (((cmp x y) < 0%Z)%Z -> ((cmp y z) = 0%Z) -> ((cmp x z) < 0%Z)%Z) /\
   (((cmp x y) < 0%Z)%Z -> ((cmp y z) < 0%Z)%Z -> ((cmp x z) < 0%Z)%Z)).

Axiom cmp_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a) (cmp:a -> a -> Numbers.BinNums.Z), is_pre_order cmp ->
  ((cmp x y) = 0%Z) <-> (x = y).

Parameter compare:
  forall {a:Type} {a_WT:WhyType a}, a -> a -> Numbers.BinNums.Z.

Axiom compare_pre_order :
  forall {a:Type} {a_WT:WhyType a},
  is_pre_order (fun (x:a) (y:a) => compare x y).

Axiom seq : forall (a:Type), Type.
Parameter seq_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (seq a).
Existing Instance seq_WhyType.

Parameter length:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z.

Axiom length_nonnegative :
  forall {a:Type} {a_WT:WhyType a}, forall (s:seq a), (0%Z <= (length s))%Z.

Parameter get:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a.

Parameter infix_eqeq1:
  forall {a:Type} {a_WT:WhyType a}, seq a -> seq a -> Prop.

Axiom infix_eqeq'spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a),
  (infix_eqeq1 s1 s2 <->
   ((length s1) = (length s2)) /\
   (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length s1))%Z ->
    ((get s1 i) = (get s2 i)))) /\
  (infix_eqeq1 s1 s2 -> (s1 = s2)).

Parameter create:
  forall {a:Type} {a_WT:WhyType a}, Numbers.BinNums.Z ->
  (Numbers.BinNums.Z -> a) -> seq a.

Axiom create'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (len:Numbers.BinNums.Z) (f:Numbers.BinNums.Z -> a),
  (0%Z <= len)%Z ->
  ((length (create len f)) = len) /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < len)%Z ->
   ((get (create len f) i) = (f i))).

Parameter empty: forall {a:Type} {a_WT:WhyType a}, seq a.

Axiom empty'def :
  forall {a:Type} {a_WT:WhyType a}, ((length (empty : seq a)) = 0%Z).

Parameter set:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a -> seq a.

Parameter result1:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a ->
  Numbers.BinNums.Z -> a.

Axiom result'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a) (j:Numbers.BinNums.Z),
  ((j = i) -> ((result1 s i v j) = v)) /\
  (~ (j = i) -> ((result1 s i v j) = (get s j))).

Axiom set'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z ->
  ((set s i v) = (create (length s) (result1 s i v))).

Axiom set'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z ->
  ((length (set s i v)) = (length s)) /\
  ((get (set s i v) i) = v) /\
  (forall (j:Numbers.BinNums.Z),
   ((0%Z <= j)%Z /\ (j < (length s))%Z) /\ ~ (j = i) ->
   ((get (set s i v) j) = (get s j))).

Parameter mixfix_lblsmnrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> a -> seq a.

Axiom mixfix_lblsmnrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length s))%Z ->
  ((mixfix_lblsmnrb s i v) = (set s i v)).

(* Why3 assumption *)
Definition singleton {a:Type} {a_WT:WhyType a} (v:a) : seq a :=
  create 1%Z (fun (us:Numbers.BinNums.Z) => v).

Axiom singleton'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (v:a),
  ((length (singleton v)) = 1%Z) /\ ((get (singleton v) 0%Z) = v).

Parameter result2:
  forall {a:Type} {a_WT:WhyType a}, a -> seq a -> Numbers.BinNums.Z -> a.

Axiom result'def1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a) (i:Numbers.BinNums.Z),
  ((i = 0%Z) -> ((result2 x s i) = x)) /\
  (~ (i = 0%Z) -> ((result2 x s i) = (get s (i - 1%Z)%Z))).

(* Why3 assumption *)
Definition cons {a:Type} {a_WT:WhyType a} (x:a) (s:seq a) : seq a :=
  create (1%Z + (length s))%Z (result2 x s).

Axiom cons'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a),
  ((length (cons x s)) = (1%Z + (length s))%Z) /\
  ((get (cons x s) 0%Z) = x) /\
  (forall (i:Numbers.BinNums.Z), (0%Z < i)%Z /\ (i <= (length s))%Z ->
   ((get (cons x s) i) = (get s (i - 1%Z)%Z))).

Parameter result3:
  forall {a:Type} {a_WT:WhyType a}, seq a -> a -> Numbers.BinNums.Z -> a.

Axiom result'def2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a) (i:Numbers.BinNums.Z),
  ((i = (length s)) -> ((result3 s x i) = x)) /\
  (~ (i = (length s)) -> ((result3 s x i) = (get s i))).

(* Why3 assumption *)
Definition snoc {a:Type} {a_WT:WhyType a} (s:seq a) (x:a) : seq a :=
  create (1%Z + (length s))%Z (result3 s x).

Axiom snoc'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (x:a),
  ((length (snoc s x)) = (1%Z + (length s))%Z) /\
  ((get (snoc s x) (length s)) = x) /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length s))%Z ->
   ((get (snoc s x) i) = (get s i))).

Parameter mixfix_lbdtdtrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> seq a.

Axiom mixfix_lbdtdtrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= j)%Z /\ (j <= (length s))%Z ->
  ((mixfix_lbdtdtrb s i j) =
   (create (j - i)%Z (fun (k:Numbers.BinNums.Z) => get s (i + k)%Z))).

Axiom mixfix_lbdtdtrb'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= j)%Z /\ (j <= (length s))%Z ->
  ((length (mixfix_lbdtdtrb s i j)) = (j - i)%Z) /\
  (forall (k:Numbers.BinNums.Z), (0%Z <= k)%Z /\ (k < (j - i)%Z)%Z ->
   ((get (mixfix_lbdtdtrb s i j) k) = (get s (i + k)%Z))).

Parameter mixfix_lb_dtdtrb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> seq a.

Axiom mixfix_lb_dtdtrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= (length s))%Z ->
  ((mixfix_lb_dtdtrb s i) = (mixfix_lbdtdtrb s i (length s))).

Parameter mixfix_lbdtdt_rb:
  forall {a:Type} {a_WT:WhyType a}, seq a -> Numbers.BinNums.Z -> seq a.

Axiom mixfix_lbdtdt_rb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:seq a) (j:Numbers.BinNums.Z),
  (0%Z <= j)%Z /\ (j <= (length s))%Z ->
  ((mixfix_lbdtdt_rb s j) = (mixfix_lbdtdtrb s 0%Z j)).

Parameter result4:
  forall {a:Type} {a_WT:WhyType a}, seq a -> seq a -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> a.

Axiom result'def3 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a) (l:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  ((i < l)%Z -> ((result4 s1 s2 l i) = (get s1 i))) /\
  (~ (i < l)%Z -> ((result4 s1 s2 l i) = (get s2 (i - l)%Z))).

(* Why3 assumption *)
Definition infix_plpl {a:Type} {a_WT:WhyType a} (s1:seq a) (s2:seq a) : seq a :=
  let l := length s1 in create (l + (length s2))%Z (result4 s1 s2 l).

Axiom infix_plpl'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:seq a) (s2:seq a),
  ((length (infix_plpl s1 s2)) = ((length s1) + (length s2))%Z) /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length s1))%Z ->
   ((get (infix_plpl s1 s2) i) = (get s1 i))) /\
  (forall (i:Numbers.BinNums.Z),
   ((length s1) <= i)%Z /\ (i < (length (infix_plpl s1 s2)))%Z ->
   ((get (infix_plpl s1 s2) i) = (get s2 (i - (length s1))%Z))).

Axiom my_array : forall (a:Type), Type.
Parameter my_array_WhyType :
  forall (a:Type) {a_WT:WhyType a}, WhyType (my_array a).
Existing Instance my_array_WhyType.

Parameter elts: forall {a:Type} {a_WT:WhyType a}, my_array a -> seq a.

Parameter length1:
  forall {a:Type} {a_WT:WhyType a}, my_array a -> Numbers.BinNums.Z.

Axiom my_array'invariant :
  forall {a:Type} {a_WT:WhyType a},
  forall (self:my_array a),
  (0%Z <= (length1 self))%Z /\ ((length1 self) = (length (elts self))).

(* Why3 assumption *)
Definition mixfix_lbrb {a:Type} {a_WT:WhyType a} (a1:my_array a)
    (i:Numbers.BinNums.Z) : a :=
  get (elts a1) i.

Parameter to_list_range:
  forall {a:Type} {a_WT:WhyType a}, my_array a -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> Init.Datatypes.list a.

Axiom to_list_range'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:my_array a) (l:Numbers.BinNums.Z) (u:Numbers.BinNums.Z),
  (0%Z <= l)%Z /\ (u <= (length1 a1))%Z ->
  ((u <= l)%Z -> ((to_list_range a1 l u) = Init.Datatypes.nil)) /\
  (~ (u <= l)%Z ->
   ((to_list_range a1 l u) =
    (Init.Datatypes.cons (mixfix_lbrb a1 l) (to_list_range a1 (l + 1%Z)%Z u)))).

Axiom to_list_append :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:my_array a) (l:Numbers.BinNums.Z) (m:Numbers.BinNums.Z)
    (u:Numbers.BinNums.Z),
  (0%Z <= l)%Z /\ (l <= m)%Z /\ (m <= u)%Z /\ (u <= (length1 a1))%Z ->
  ((Init.Datatypes.app (to_list_range a1 l m) (to_list_range a1 m u)) =
   (to_list_range a1 l u)).

(* Why3 assumption *)
Definition mem {a:Type} {a_WT:WhyType a} (x:a) (s:seq a) : Prop :=
  exists i:Numbers.BinNums.Z,
  ((0%Z <= i)%Z /\ (i < (length s))%Z) /\ ((get s i) = x).

Axiom mem_append :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s1:seq a) (s2:seq a),
  mem x (infix_plpl s1 s2) <-> mem x s1 \/ mem x s2.

Axiom mem_tail :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:seq a), (0%Z < (length s))%Z ->
  mem x s <-> (x = (get s 0%Z)) \/ mem x (mixfix_lb_dtdtrb s 1%Z).

(* Why3 assumption *)
Definition mem1 {a:Type} {a_WT:WhyType a} (x:a) (a1:my_array a) : Prop :=
  mem x (elts a1).

(* Why3 assumption *)
Definition array (a:Type) := my_array a.

Parameter max_array_length: Numbers.BinNums.Z.

Axiom non_neg_max_array_length : (0%Z < max_array_length)%Z.

Parameter assoc_opt:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  (a -> a -> Init.Datatypes.bool) -> a -> Init.Datatypes.list (a* b)%type ->
  Init.Datatypes.option b.

Axiom assoc_opt'def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (eq:a -> a -> Init.Datatypes.bool) (x:a)
    (l:Init.Datatypes.list (a* b)%type),
  match l with
  | Init.Datatypes.nil => ((assoc_opt eq x l) = Init.Datatypes.None)
  | Init.Datatypes.cons (a1, b1) tl =>
      (((eq x a1) = Init.Datatypes.true) ->
       ((assoc_opt eq x l) = (Init.Datatypes.Some b1))) /\
      (~ ((eq x a1) = Init.Datatypes.true) ->
       ((assoc_opt eq x l) = (assoc_opt eq x tl)))
  end.

Parameter concat: BuiltIn.string -> BuiltIn.string -> BuiltIn.string.

Axiom concat_assoc :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (s3:BuiltIn.string),
  ((concat (concat s1 s2) s3) = (concat s1 (concat s2 s3))).

Parameter rliteral: BuiltIn.string.

Axiom rliteral_axiom : True.

Axiom concat_empty :
  forall (s:BuiltIn.string),
  ((concat s rliteral) = (concat rliteral s)) /\ ((concat rliteral s) = s).

Parameter length2: BuiltIn.string -> Numbers.BinNums.Z.

Axiom length_empty : ((length2 rliteral) = 0%Z).

Axiom length_concat :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  ((length2 (concat s1 s2)) = ((length2 s1) + (length2 s2))%Z).

Parameter lt: BuiltIn.string -> BuiltIn.string -> Prop.

Axiom lt_empty :
  forall (s:BuiltIn.string), ~ (s = rliteral) -> lt rliteral s.

Axiom lt_not_com :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), lt s1 s2 -> ~ lt s2 s1.

Axiom lt_ref : forall (s1:BuiltIn.string), ~ lt s1 s1.

Axiom lt_trans :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (s3:BuiltIn.string),
  lt s1 s2 /\ lt s2 s3 -> lt s1 s3.

Parameter le: BuiltIn.string -> BuiltIn.string -> Prop.

Axiom le_empty : forall (s:BuiltIn.string), le rliteral s.

Axiom le_ref : forall (s1:BuiltIn.string), le s1 s1.

Axiom lt_le :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), lt s1 s2 -> le s1 s2.

Axiom lt_le_eq :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), le s1 s2 ->
  lt s1 s2 \/ (s1 = s2).

Axiom le_trans :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (s3:BuiltIn.string),
  le s1 s2 /\ le s2 s3 -> le s1 s3.

Parameter s_at: BuiltIn.string -> Numbers.BinNums.Z -> BuiltIn.string.

Axiom at_out_of_range :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z),
  (i < 0%Z)%Z \/ ((length2 s) <= i)%Z -> ((s_at s i) = rliteral).

Axiom at_empty :
  forall (i:Numbers.BinNums.Z), ((s_at rliteral i) = rliteral).

Axiom at_length :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z),
  let j := s_at s i in
  ((0%Z <= i)%Z /\ (i < (length2 s))%Z -> ((length2 j) = 1%Z)) /\
  (~ ((0%Z <= i)%Z /\ (i < (length2 s))%Z) -> ((length2 j) = 0%Z)).

Axiom concat_at :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  let s := concat s1 s2 in
  forall (i:Numbers.BinNums.Z),
  ((0%Z <= i)%Z /\ (i < (length2 s1))%Z -> ((s_at s i) = (s_at s1 i))) /\
  (((length2 s1) <= i)%Z /\ (i < (length2 s))%Z ->
   ((s_at s i) = (s_at s2 (i - (length2 s1))%Z))).

Parameter substring:
  BuiltIn.string -> Numbers.BinNums.Z -> Numbers.BinNums.Z -> BuiltIn.string.

Axiom substring_out_of_range :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  (i < 0%Z)%Z \/ ((length2 s) <= i)%Z -> ((substring s i x) = rliteral).

Axiom substring_of_length_zero_or_less :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  (x <= 0%Z)%Z -> ((substring s i x) = rliteral).

Axiom substring_of_empty :
  forall (i:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  ((substring rliteral i x) = rliteral).

Axiom substring_smaller :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  ((length2 (substring s i x)) <= (length2 s))%Z.

Axiom substring_smaller_x :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  (0%Z <= x)%Z -> ((length2 (substring s i x)) <= x)%Z.

Axiom substring_length :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  (0%Z <= x)%Z /\ (0%Z <= i)%Z /\ (i < (length2 s))%Z ->
  (((length2 s) < (i + x)%Z)%Z ->
   ((length2 (substring s i x)) = ((length2 s) - i)%Z)) /\
  (~ ((length2 s) < (i + x)%Z)%Z -> ((length2 (substring s i x)) = x)).

Axiom substring_at :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z),
  ((s_at s i) = (substring s i 1%Z)).

Axiom substring_substring :
  forall (s:BuiltIn.string) (ofs:Numbers.BinNums.Z) (len:Numbers.BinNums.Z)
    (ofs':Numbers.BinNums.Z) (len':Numbers.BinNums.Z),
  (0%Z <= ofs)%Z /\ (ofs <= (length2 s))%Z -> (0%Z <= len)%Z ->
  ((ofs + len)%Z <= (length2 s))%Z -> (0%Z <= ofs')%Z /\ (ofs' <= len)%Z ->
  (0%Z <= len')%Z -> ((ofs' + len')%Z <= len)%Z ->
  ((substring (substring s ofs len) ofs' len') =
   (substring s (ofs + ofs')%Z len')).

Axiom concat_substring :
  forall (s:BuiltIn.string) (ofs:Numbers.BinNums.Z) (len:Numbers.BinNums.Z)
    (len':Numbers.BinNums.Z),
  (0%Z <= ofs)%Z /\ (ofs <= (length2 s))%Z -> (0%Z <= len)%Z ->
  ((ofs + len)%Z <= (length2 s))%Z -> (0%Z <= len')%Z ->
  (0%Z <= ((ofs + len)%Z + len')%Z)%Z /\
  (((ofs + len)%Z + len')%Z <= (length2 s))%Z ->
  ((concat (substring s ofs len) (substring s (ofs + len)%Z len')) =
   (substring s ofs (len + len')%Z)).

Parameter prefixof: BuiltIn.string -> BuiltIn.string -> Prop.

Axiom prefixof_substring :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  prefixof s1 s2 <-> (s1 = (substring s2 0%Z (length2 s1))).

Axiom prefixof_concat :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), prefixof s1 (concat s1 s2).

Axiom prefixof_empty : forall (s2:BuiltIn.string), prefixof rliteral s2.

Axiom prefixof_empty2 :
  forall (s1:BuiltIn.string), ~ (s1 = rliteral) -> ~ prefixof s1 rliteral.

Parameter suffixof: BuiltIn.string -> BuiltIn.string -> Prop.

Axiom suffixof_substring :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  suffixof s1 s2 <->
  (s1 = (substring s2 ((length2 s2) - (length2 s1))%Z (length2 s1))).

Axiom suffixof_concat :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), suffixof s2 (concat s1 s2).

Axiom suffixof_empty : forall (s2:BuiltIn.string), suffixof rliteral s2.

Axiom suffixof_empty2 :
  forall (s1:BuiltIn.string), ~ (s1 = rliteral) -> ~ suffixof s1 rliteral.

Parameter contains: BuiltIn.string -> BuiltIn.string -> Prop.

Axiom contains_prefixof :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), prefixof s1 s2 ->
  contains s2 s1.

Axiom contains_suffixof :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), suffixof s1 s2 ->
  contains s2 s1.

Axiom contains_empty :
  forall (s2:BuiltIn.string), contains rliteral s2 <-> (s2 = rliteral).

Axiom contains_empty2 : forall (s1:BuiltIn.string), contains s1 rliteral.

Axiom contains_substring :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (i:Numbers.BinNums.Z),
  ((substring s1 i (length2 s2)) = s2) -> contains s1 s2.

Axiom contains_concat :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  contains (concat s1 s2) s1 /\ contains (concat s1 s2) s2.

Axiom contains_at :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (i:Numbers.BinNums.Z),
  ((s_at s1 i) = s2) -> contains s1 s2.

Parameter indexof:
  BuiltIn.string -> BuiltIn.string -> Numbers.BinNums.Z -> Numbers.BinNums.Z.

Axiom indexof_empty :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= (length2 s))%Z -> ((indexof s rliteral i) = i).

Axiom indexof_empty1 :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z),
  let j := indexof rliteral s i in
  (j = (-1%Z)%Z) \/ (s = rliteral) /\ (i = j) /\ (j = 0%Z).

Axiom indexof_contains :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  let j := indexof s1 s2 0%Z in
  contains s1 s2 ->
  ((0%Z <= j)%Z /\ (j <= (length2 s1))%Z) /\
  ((substring s1 j (length2 s2)) = s2).

Axiom contains_indexof :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (i:Numbers.BinNums.Z),
  (0%Z <= (indexof s1 s2 i))%Z -> contains s1 s2.

Axiom not_contains_indexof :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (i:Numbers.BinNums.Z),
  ~ contains s1 s2 -> ((indexof s1 s2 i) = (-1%Z)%Z).

Axiom substring_indexof :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (i:Numbers.BinNums.Z),
  let j := indexof s1 s2 i in
  (0%Z <= j)%Z -> ((substring s1 j (length2 s2)) = s2).

Axiom indexof_out_of_range :
  forall (i:Numbers.BinNums.Z) (s1:BuiltIn.string) (s2:BuiltIn.string),
  ~ ((0%Z <= i)%Z /\ (i <= (length2 s1))%Z) -> ((indexof s1 s2 i) = (-1%Z)%Z).

Axiom indexof_in_range :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (i:Numbers.BinNums.Z),
  let j := indexof s1 s2 i in
  (0%Z <= i)%Z /\ (i <= (length2 s1))%Z ->
  (j = (-1%Z)%Z) \/ (i <= j)%Z /\ (j <= (length2 s1))%Z.

Axiom indexof_contains_substring :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (i:Numbers.BinNums.Z),
  ((0%Z <= i)%Z /\ (i <= (length2 s1))%Z) /\
  contains (substring s1 i ((length2 s1) - i)%Z) s2 ->
  (i <= (indexof s1 s2 i))%Z /\ ((indexof s1 s2 i) <= (length2 s1))%Z.

Parameter replace:
  BuiltIn.string -> BuiltIn.string -> BuiltIn.string -> BuiltIn.string.

Axiom replace_empty :
  forall (s1:BuiltIn.string) (s3:BuiltIn.string),
  ((replace s1 rliteral s3) = (concat s3 s1)).

Axiom replace_not_contains :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (s3:BuiltIn.string),
  ~ contains s1 s2 -> ((replace s1 s2 s3) = s1).

Axiom replace_empty2 :
  forall (s2:BuiltIn.string) (s3:BuiltIn.string),
  let s4 := replace rliteral s2 s3 in
  ((s2 = rliteral) -> (s4 = s3)) /\ (~ (s2 = rliteral) -> (s4 = rliteral)).

Axiom replace_substring_indexof :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (s3:BuiltIn.string),
  let j := indexof s1 s2 0%Z in
  ((j < 0%Z)%Z -> ((replace s1 s2 s3) = s1)) /\
  (~ (j < 0%Z)%Z ->
   ((replace s1 s2 s3) =
    (concat (concat (substring s1 0%Z j) s3)
     (substring s1 (j + (length2 s2))%Z
      (((length2 s1) - j)%Z - (length2 s2))%Z)))).

Parameter replaceall:
  BuiltIn.string -> BuiltIn.string -> BuiltIn.string -> BuiltIn.string.

Axiom replaceall_empty1 :
  forall (s1:BuiltIn.string) (s3:BuiltIn.string),
  ((replaceall s1 rliteral s3) = s1).

Axiom not_contains_replaceall :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (s3:BuiltIn.string),
  ~ contains s1 s2 -> ((replaceall s1 s2 s3) = s1).

Parameter to_int: BuiltIn.string -> Numbers.BinNums.Z.

Axiom to_int_gt_minus_1 :
  forall (s:BuiltIn.string), ((-1%Z)%Z <= (to_int s))%Z.

Axiom to_int_empty : ((to_int rliteral) = (-1%Z)%Z).

(* Why3 assumption *)
Definition is_digit (s:BuiltIn.string) : Prop :=
  ((0%Z <= (to_int s))%Z /\ ((to_int s) <= 9%Z)%Z) /\ ((length2 s) = 1%Z).

Parameter from_int: Numbers.BinNums.Z -> BuiltIn.string.

Axiom from_int_negative :
  forall (i:Numbers.BinNums.Z), (i < 0%Z)%Z <-> ((from_int i) = rliteral).

Axiom from_int_to_int :
  forall (i:Numbers.BinNums.Z),
  ((0%Z <= i)%Z -> ((to_int (from_int i)) = i)) /\
  (~ (0%Z <= i)%Z -> ((to_int (from_int i)) = (-1%Z)%Z)).

Axiom char : Type.
Parameter char_WhyType : WhyType char.
Existing Instance char_WhyType.

Parameter contents1: char -> BuiltIn.string.

Axiom char'invariant :
  forall (self:char), ((length2 (contents1 self)) = 1%Z).

Axiom char_eq :
  forall (c1:char) (c2:char), ((contents1 c1) = (contents1 c2)) -> (c1 = c2).

Parameter code: char -> Numbers.BinNums.Z.

Axiom code1 : forall (c:char), (0%Z <= (code c))%Z /\ ((code c) < 256%Z)%Z.

Parameter chr: Numbers.BinNums.Z -> char.

Axiom code_chr :
  forall (n:Numbers.BinNums.Z), (0%Z <= n)%Z /\ (n < 256%Z)%Z ->
  ((code (chr n)) = n).

Axiom chr_code : forall (c:char), ((chr (code c)) = c).

Parameter get1: BuiltIn.string -> Numbers.BinNums.Z -> char.

Axiom get2 :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length2 s))%Z ->
  ((contents1 (get1 s i)) = (s_at s i)).

Axiom substring_get :
  forall (s:BuiltIn.string) (ofs:Numbers.BinNums.Z) (len:Numbers.BinNums.Z)
    (i:Numbers.BinNums.Z),
  (0%Z <= ofs)%Z /\ (ofs <= (length2 s))%Z -> (0%Z <= len)%Z ->
  ((ofs + len)%Z <= (length2 s))%Z -> (0%Z <= i)%Z /\ (i < len)%Z ->
  ((get1 (substring s ofs len) i) = (get1 s (ofs + i)%Z)).

Axiom concat_first :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length2 s1))%Z ->
  ((get1 (concat s1 s2) i) = (get1 s1 i)).

Axiom concat_second :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  forall (i:Numbers.BinNums.Z),
  ((length2 s1) <= i)%Z /\ (i < ((length2 s1) + (length2 s2))%Z)%Z ->
  ((get1 (concat s1 s2) i) = (get1 s2 (i - (length2 s1))%Z)).

(* Why3 assumption *)
Definition eq_string (s1:BuiltIn.string) (s2:BuiltIn.string) : Prop :=
  ((length2 s1) = (length2 s2)) /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length2 s1))%Z ->
   ((get1 s1 i) = (get1 s2 i))).

Axiom extensionality :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), eq_string s1 s2 ->
  (s1 = s2).

Parameter make: Numbers.BinNums.Z -> char -> BuiltIn.string.

Axiom make_length :
  forall (size:Numbers.BinNums.Z) (v:char), (0%Z <= size)%Z ->
  ((length2 (make size v)) = size).

Axiom make_contents :
  forall (size:Numbers.BinNums.Z) (v:char), (0%Z <= size)%Z ->
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < size)%Z ->
  ((get1 (make size v) i) = v).

Parameter eq: BuiltIn.string -> BuiltIn.string -> Init.Datatypes.bool.

Axiom eq'spec :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  ((eq s1 s2) = Init.Datatypes.true) <-> eq_string s1 s2.

(* Why3 assumption *)
Inductive nat :=
  | Nat : Numbers.BinNums.Z -> nat.
Axiom nat_WhyType : WhyType nat.
Existing Instance nat_WhyType.

(* Why3 assumption *)
Definition t := nat.

(* Why3 assumption *)
Definition eq1 (n1:nat) (n2:nat) : Init.Datatypes.bool :=
  match (n1, n2) with
  | (Nat n11, Nat n21) => infix_eqeq n11 n21
  | (_, _) => Init.Datatypes.false
  end.

Parameter lt1: nat -> nat -> Init.Datatypes.bool.

Axiom lt'def :
  forall (n1:nat) (n2:nat),
  match (n1, n2) with
  | (Nat n11, Nat n21) =>
      ((n11 < n21)%Z -> ((lt1 n1 n2) = Init.Datatypes.true)) /\
      (~ (n11 < n21)%Z -> ((lt1 n1 n2) = Init.Datatypes.false))
  | (_, _) => ((lt1 n1 n2) = Init.Datatypes.false)
  end.

(* Why3 assumption *)
Definition add (n1:nat) (n2:nat) : nat :=
  match (n1, n2) with
  | (Nat n11, Nat n21) => Nat (n11 + n21)%Z
  end.

(* Why3 assumption *)
Inductive tz :=
  | Tz : Numbers.BinNums.Z -> tz.
Axiom tz_WhyType : WhyType tz.
Existing Instance tz_WhyType.

(* Why3 assumption *)
Definition t1 := tz.

Parameter eq2: tz -> tz -> Init.Datatypes.bool.

Axiom eq'def :
  forall (t11:tz) (t2:tz),
  match (t11, t2) with
  | (Tz n1, Tz n2) =>
      ((n1 = n2) -> ((eq2 t11 t2) = Init.Datatypes.true)) /\
      (~ (n1 = n2) -> ((eq2 t11 t2) = Init.Datatypes.false))
  | (_, _) => ((eq2 t11 t2) = Init.Datatypes.false)
  end.

(* Why3 assumption *)
Inductive set1 (a:Type) :=
  | Set1 : Init.Datatypes.list a -> set1 a.
Axiom set1_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (set1 a).
Existing Instance set1_WhyType.
Arguments Set1 {a}.

(* Why3 assumption *)
Definition t2 (a:Type) := set1 a.

Parameter mem2:
  forall {a:Type} {a_WT:WhyType a}, a -> set1 a -> Init.Datatypes.bool.

Axiom mem'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (sxs:set1 a),
  match sxs with
  | Set1 xs =>
      (list.Mem.mem x xs -> ((mem2 x sxs) = Init.Datatypes.true)) /\
      (~ list.Mem.mem x xs -> ((mem2 x sxs) = Init.Datatypes.false))
  end.

Parameter update:
  forall {a:Type} {a_WT:WhyType a}, (a -> a -> Init.Datatypes.bool) ->
  (a -> a -> Init.Datatypes.bool) -> a -> Init.Datatypes.bool -> set1 a ->
  set1 a.

(* Why3 assumption *)
Inductive map (k:Type)
  (v:Type) :=
  | Map : Init.Datatypes.list (k* v)%type -> map k v.
Axiom map_WhyType : forall (k:Type) {k_WT:WhyType k}
  (v:Type) {v_WT:WhyType v}, WhyType (map k v).
Existing Instance map_WhyType.
Arguments Map {k} {v}.

(* Why3 assumption *)
Definition t3 (k:Type) (v:Type) := map k v.

(* Why3 assumption *)
Definition get3 {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}
    (eq3:k -> k -> Init.Datatypes.bool) (k1:k) (mxs:map k v) :
    Init.Datatypes.option v :=
  match mxs with
  | Map xs => assoc_opt eq3 k1 xs
  | _ => Init.Datatypes.None
  end.

Parameter update1:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  (k -> k -> Init.Datatypes.bool) -> (k -> k -> Init.Datatypes.bool) -> k ->
  Init.Datatypes.option v -> map k v -> map k v.

Axiom update'spec :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (eq3:k -> k -> Init.Datatypes.bool)
    (lt2:k -> k -> Init.Datatypes.bool) (k1:k) (vo:Init.Datatypes.option v)
    (mkvs:map k v),
  match vo with
  | Init.Datatypes.None =>
      option.Option.is_none (get3 eq3 k1 (update1 eq3 lt2 k1 vo mkvs))
  | Init.Datatypes.Some v1 =>
      match get3 eq3 k1 (update1 eq3 lt2 k1 vo mkvs) with
      | Init.Datatypes.Some v' => (v1 = v')
      | _ => False
      end
  end.

Parameter add1:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  (k -> k -> Init.Datatypes.bool) -> (k -> k -> Init.Datatypes.bool) -> k ->
  v -> map k v -> map k v.

(* Why3 assumption *)
Inductive address :=
  | Address : BuiltIn.string -> address.
Axiom address_WhyType : WhyType address.
Existing Instance address_WhyType.

(* Why3 assumption *)
Definition t4 := address.

(* Why3 assumption *)
Definition eq3 (a1:address) (a2:address) : Init.Datatypes.bool :=
  match (a1, a2) with
  | (Address s1, Address s2) => eq s1 s2
  | (_, _) => Init.Datatypes.false
  end.

Parameter lt2: address -> address -> Init.Datatypes.bool.

Axiom lt'def1 :
  forall (a1:address) (a2:address),
  match (a1, a2) with
  | (Address s1, Address s2) =>
      (lt s1 s2 -> ((lt2 a1 a2) = Init.Datatypes.true)) /\
      (~ lt s1 s2 -> ((lt2 a1 a2) = Init.Datatypes.false))
  | (_, _) => ((lt2 a1 a2) = Init.Datatypes.false)
  end.

(* Why3 assumption *)
Inductive key_hash :=
  | Key_hash : BuiltIn.string -> key_hash.
Axiom key_hash_WhyType : WhyType key_hash.
Existing Instance key_hash_WhyType.

(* Why3 assumption *)
Inductive t5 :=
  | Key_hash1 : t5.
Axiom t5_WhyType : WhyType t5.
Existing Instance t5_WhyType.

(* Why3 assumption *)
Inductive rep :=
  | RepInt : rep
  | RepUnit : rep
  | RepPair : (rep* rep)%type -> rep.
Axiom rep_WhyType : WhyType rep.
Existing Instance rep_WhyType.

(* Why3 assumption *)
Inductive param :=
  | ParamInt : Numbers.BinNums.Z -> param
  | ParamUnit : param
  | ParamPair : (param* param)%type -> param.
Axiom param_WhyType : WhyType param.
Existing Instance param_WhyType.

(* Why3 assumption *)
Inductive contract :=
  | Contract : (address* rep)%type -> contract.
Axiom contract_WhyType : WhyType contract.
Existing Instance contract_WhyType.

(* Why3 assumption *)
Inductive operation :=
  | Transfer_tokens : param -> tz -> contract -> operation.
Axiom operation_WhyType : WhyType operation.
Existing Instance operation_WhyType.

(* Why3 assumption *)
Definition operations := Init.Datatypes.list operation.

(* Why3 assumption *)
Definition t6 := contract.

Parameter contract1: address -> param -> Init.Datatypes.option contract.

(* Why3 assumption *)
Definition t7 := operation.

(* Why3 assumption *)
Inductive timestamp :=
  | Timestamp : BuiltIn.string -> timestamp.
Axiom timestamp_WhyType : WhyType timestamp.
Existing Instance timestamp_WhyType.

(* Why3 assumption *)
Definition t8 := timestamp.

Parameter lt3: timestamp -> timestamp -> Init.Datatypes.bool.

Axiom lt'def2 :
  forall (t11:timestamp) (t21:timestamp),
  match (t11, t21) with
  | (Timestamp s1, Timestamp s2) =>
      (lt s1 s2 -> ((lt3 t11 t21) = Init.Datatypes.true)) /\
      (~ lt s1 s2 -> ((lt3 t11 t21) = Init.Datatypes.false))
  | (_, _) => ((lt3 t11 t21) = Init.Datatypes.false)
  end.

Parameter le1: timestamp -> timestamp -> Init.Datatypes.bool.

Axiom le'def :
  forall (t11:timestamp) (t21:timestamp),
  match (t11, t21) with
  | (Timestamp s1, Timestamp s2) =>
      (le s1 s2 -> ((le1 t11 t21) = Init.Datatypes.true)) /\
      (~ le s1 s2 -> ((le1 t11 t21) = Init.Datatypes.false))
  | (_, _) => ((le1 t11 t21) = Init.Datatypes.false)
  end.

(* Why3 assumption *)
Inductive t9 :=
  | t'mk : timestamp -> tz -> address -> address -> t9.
Axiom t9_WhyType : WhyType t9.
Existing Instance t9_WhyType.

(* Why3 assumption *)
Definition env_sender (v:t9) : address :=
  match v with
  | t'mk x x1 x2 x3 => x3
  end.

(* Why3 assumption *)
Definition env_source (v:t9) : address :=
  match v with
  | t'mk x x1 x2 x3 => x2
  end.

(* Why3 assumption *)
Definition env_amount (v:t9) : tz := match v with
                                     | t'mk x x1 x2 x3 => x1
                                     end.

(* Why3 assumption *)
Definition env_now (v:t9) : timestamp :=
  match v with
  | t'mk x x1 x2 x3 => x
  end.

(* Why3 assumption *)
Definition key := BuiltIn.string.

(* Why3 assumption *)
Definition t10 := BuiltIn.string.

(* Why3 assumption *)
Inductive signature :=
  | Signature : BuiltIn.string -> signature.
Axiom signature_WhyType : WhyType signature.
Existing Instance signature_WhyType.

(* Why3 assumption *)
Definition t11 := signature.

(* Why3 assumption *)
Inductive config :=
  | config'mk : BuiltIn.string -> timestamp -> timestamp -> config.
Axiom config_WhyType : WhyType config.
Existing Instance config_WhyType.

(* Why3 assumption *)
Definition finish_time (v:config) : timestamp :=
  match v with
  | config'mk x x1 x2 => x2
  end.

(* Why3 assumption *)
Definition beginning_time (v:config) : timestamp :=
  match v with
  | config'mk x x1 x2 => x1
  end.

(* Why3 assumption *)
Definition title (v:config) : BuiltIn.string :=
  match v with
  | config'mk x x1 x2 => x
  end.

(* Why3 assumption *)
Inductive action :=
  | Vote : BuiltIn.string -> action
  | Init : config -> action.
Axiom action_WhyType : WhyType action.
Existing Instance action_WhyType.

(* Why3 assumption *)
Inductive storage :=
  | storage'mk : config -> map BuiltIn.string Numbers.BinNums.Z ->
      set1 address -> storage.
Axiom storage_WhyType : WhyType storage.
Existing Instance storage_WhyType.

(* Why3 assumption *)
Definition voters (v:storage) : set1 address :=
  match v with
  | storage'mk x x1 x2 => x2
  end.

(* Why3 assumption *)
Definition candidates (v:storage) : map BuiltIn.string Numbers.BinNums.Z :=
  match v with
  | storage'mk x x1 x2 => x1
  end.

(* Why3 assumption *)
Definition config1 (v:storage) : config :=
  match v with
  | storage'mk x x1 x2 => x
  end.

Parameter if_term: storage -> timestamp -> Init.Datatypes.bool.

Parameter eq_string_closure:
  BuiltIn.string -> BuiltIn.string -> Init.Datatypes.bool.

Parameter lt_closure:
  BuiltIn.string -> BuiltIn.string -> Init.Datatypes.bool.

Axiom if_term'def :
  forall (storage1:storage) (now:timestamp),
  (((le1 (beginning_time (config1 storage1)) now) = Init.Datatypes.true) ->
   ((if_term storage1 now) = (lt3 now (finish_time (config1 storage1))))) /\
  (~ ((le1 (beginning_time (config1 storage1)) now) = Init.Datatypes.true) ->
   ((if_term storage1 now) = Init.Datatypes.false)).

Axiom eq_string_closure_def :
  forall (y:BuiltIn.string) (y1:BuiltIn.string),
  ((eq_string_closure y y1) = Init.Datatypes.true) <-> eq_string y y1.

Axiom lt_closure_def :
  forall (y:BuiltIn.string) (y1:BuiltIn.string),
  ((lt_closure y y1) = Init.Datatypes.true) <-> lt y y1.

(* Why3 goal *)
Theorem vote'vc :
  forall (env:t9) (name:BuiltIn.string) (storage1:storage),
  let o := if_term storage1 (env_now env) in
  ((o = Init.Datatypes.true) ->
   (let addr := env_source env in
    (~ ((mem2 addr (voters storage1)) = Init.Datatypes.true) ->
     (let o1 := fun (y0:BuiltIn.string) (y1:BuiltIn.string) => eq y0 y1 in
      (o1 = eq_string_closure) ->
      (forall (x:Numbers.BinNums.Z),
       match get3 o1 name (candidates storage1) with
       | Init.Datatypes.Some i => (x = i)
       | Init.Datatypes.None => (x = 0%Z)
       end ->
       (let o2 := fun (y0:BuiltIn.string) (y1:BuiltIn.string) => eq y0 y1 in
        (o2 = eq_string_closure) ->
        (let o3 :=
         update1 o2 lt_closure name (Init.Datatypes.Some (x + 1%Z)%Z)
         (candidates storage1) in
         match get3 o2 name o3 with
         | Init.Datatypes.Some v' => ((x + 1%Z)%Z = v')
         | _ => False
         end ->
         (forall (nm:BuiltIn.string),
          let now := env_now env in
          ((le1 (beginning_time (config1 storage1)) now) =
           Init.Datatypes.true) /\
          ((lt3 now (finish_time (config1 storage1))) = Init.Datatypes.true) /\
          ~ ((mem2 (env_source env) (voters storage1)) = Init.Datatypes.true) ->
          match get3
                (fun (y0:BuiltIn.string) (y1:BuiltIn.string) => eq y0 y1) nm
                o3 with
          | Init.Datatypes.Some x1 =>
              match get3
                    (fun (y0:BuiltIn.string) (y1:BuiltIn.string) => eq y0 y1)
                    nm (candidates storage1) with
              | Init.Datatypes.Some x2 =>
                  (((eq name nm) = Init.Datatypes.true) ->
                   ((x2 + 1%Z)%Z = x1)) /\
                  (~ ((eq name nm) = Init.Datatypes.true) -> (x2 = x1))
              | Init.Datatypes.None =>
                  ((eq name nm) = Init.Datatypes.true) /\ (x1 = 1%Z)
              end
          | _ => True
          end)))))) /\
    (((mem2 addr (voters storage1)) = Init.Datatypes.true) ->
     (let now := env_now env in
      ~ (((le1 (beginning_time (config1 storage1)) now) =
          Init.Datatypes.true) /\
         ((lt3 now (finish_time (config1 storage1))) = Init.Datatypes.true) /\
         ~ ((mem2 (env_source env) (voters storage1)) = Init.Datatypes.true)))))) /\
  (~ (o = Init.Datatypes.true) ->
   (let now := env_now env in
    ~ (((le1 (beginning_time (config1 storage1)) now) = Init.Datatypes.true) /\
       ((lt3 now (finish_time (config1 storage1))) = Init.Datatypes.true) /\
       ~ ((mem2 (env_source env) (voters storage1)) = Init.Datatypes.true)))).
Proof.
intros env name storage1 o.

Qed.

